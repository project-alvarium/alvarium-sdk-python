import ulid
import json

from typing import List
from dataclasses import dataclass
from enum import Enum
from alvarium.hash.contracts import HashType
from datetime import datetime, timezone

class AnnotationType(Enum):
    TPM = "tpm"
    PKI = "pki"
    TLS = "tls"
    SOURCE = "source"
    MOCK = "mock"

    def __str__(self) -> str:
        return f'{self.value}'

@dataclass
class Annotation:
    """A data class that encapsulates all of the data related to a specific annotation.
    this will be generated by the annotators."""

    key: str
    hash: HashType
    host: str
    kind: AnnotationType 
    signature: str
    is_satisfied: bool
    timestamp: str = datetime.now(timezone.utc).astimezone().isoformat()
    id: ulid.ULID = ulid.new()

    def to_json(self) -> str:
        # TODO (karim elghamry): check if signature is present before serializing
        # if not present, return json without the signature prop
        annotation_json = {"id": str(self.id), "key": str(self.key), "hash": str(self.hash),
                           "host": str(self.host), "kind": str(self.kind), "signature": str(self.signature),
                           "isSatisfied": self.is_satisfied, "timestamp": str(self.timestamp)}
        return json.dumps(annotation_json)

    @staticmethod
    def from_json(data: str):
        annotation_json = json.loads(data)
        return Annotation(id=ulid.from_str(annotation_json["id"]), key=annotation_json["key"],
                          hash=HashType(annotation_json["hash"]), host=annotation_json["host"],
                          kind=AnnotationType(annotation_json["kind"]), signature=annotation_json["signature"],
                          is_satisfied=bool(annotation_json["isSatisfied"]), timestamp=annotation_json["timestamp"])

    def __str__(self) -> str:
        return self.to_json() 


@dataclass
class AnnotationList:
    items: List[Annotation]

    def to_json(self) -> str:
        annotation_list_json = {"items": [json.loads(str(item)) for item in self.items]}
        return json.dumps(annotation_list_json)
    
    @staticmethod
    def from_json(data: str):
        annotation_list_json = json.loads(data)
        return AnnotationList(items=[Annotation.from_json(json.dumps(item)) for item in annotation_list_json["items"]])

    def __str__(self) -> str:
        self.to_json() 
    
